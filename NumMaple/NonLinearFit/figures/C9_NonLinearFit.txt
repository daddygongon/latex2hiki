非線形最小2乗法
ー数値計算(11/12/9)ー
関西学院大学理工学部 西谷滋人
Copyright @2007-11 by Shigeto R. Nishitani
非線形最小2乗法の原理

前回の授業では，データに近似的にフィットする最小二乗法を紹介した．今回は，フィット式が多項式のような線形関係にない関数の最小二乗法を紹介する．図のようなデータに
フィットする場合を考えよう．
  

直観的な解説
このデータにあてはめるのはローレンツ関数，
"F(x ;a)=a[1]+(a[2])/(a[3]+(x-a[4])^(2))"
である．この関数の特徴は，今まで見てきた関数と違いパラメータが線形関係になっていない．誤差関数は，いままでと同様に
"chi^(2)(a)=(&sum;)d[i]^(2)=(&sum;)(F(x[i] ;a)-y[i])^(2)"
で，a"={a[0], a[1],
..}"をパラメータとして変えた時に最小となる値を求める点もかわらない．しかし，線形の最小二乗法のように微分しても一元の方程式にならず，連立方程式を単に解くだけ
では求まらない．
そこで図のような2次関数の最小値を求める場合を考える．最小値の点a[0]のまわりで，Taylor展開すると
chi(a)^2 = chi(a[0])^2-d(a-a[0])+(1/2)*D(a-a[0])^2
であるから，最小の点a[0]は
"a[0]=a+D^(-1)"×(-"d)"
と予測される．図を参照して上の式を導け．またその意味を考察せよ．



現実には高次項の影響で計算通りにはいかず，単に最小値の近似値を求めるだけである．これは，chi(a)^2の微分関数の解をNewton法で求める操作に対応する．つ
まり，この操作を何度も繰り返せばいずれ解がある精度で求まるはず．
具体的な手順
パラメータの初期値をa[0]+Delta*a, b[0]+Delta*b, c[0]+Delta*c,
d[0]+Delta*dとする．このとき関数fを真値a[0], b[0], c[0], d[0]のまわりでテイラー展開し，高次項を無視すると
Delta*f = f(a[0]+Delta*a[1], b[0]+Delta*b[1], c[0]+Delta*c[1],
d[0]+Delta*d[1])-f(a[0], b[0], c[0], d[0])
"=((&PartialD;)/(&PartialD; a)f)[0] Deltaa[1]+((&PartialD;)/(&PartialD; b)f)[0]
Deltab[1]+((&PartialD;)/(&PartialD; c)f)[0] Deltac[1]+((&PartialD;)/(&PartialD;
d)f)[0] Deltad[1]"" (1.2.1)"
となる．
課題でつくったデータはt = 1からt = 256までの時刻に対応したデータ点f[1], f[2],
`&ctdot;`(f[256])とする．各測定値とモデル関数から予想される値との差"Deltaf[1], Deltaf[2],
&ctdot;,Deltaf[256]"
"[[[Delta(f[1])[]],[Delta(f[2])[]],[&vellip;],[Delta (f[256])[]]]]= J
[[[Deltaa[1]],[Deltab[1]],[Deltac[1]],[Deltad[1]]]] (1.2.2)"
となる．ここでJはヤコビ行列と呼ばれる行列で，4行256列
"J=[[[((&PartialD;)/(&PartialD; a)f)[1],((&PartialD;)/(&PartialD;
b)f)[1],((&PartialD;)/(&PartialD; c)f)[1],((&PartialD;)/(&PartialD;
d)f)[1]],[&vellip;,&vellip;,&vellip;,&vellip;],[((&PartialD;)/(&PartialD;
a)f)[256],((&PartialD;)/(&PartialD; b)f)[256],((&PartialD;)/(&PartialD;
c)f)[256],((&PartialD;)/(&PartialD; d)f)[256]]]] (1.2.3)"
である．このような矩形行列の逆行列は転置行列J^T*`を用いて，`
"J^(-1)=(J^(T)J)^(-1)J^(T) (1.2.4)"
と表わされる．したがって，真値からのずれは
(Vector(4, {(1) = Delta*a[2], (2) = Delta*b[2], (3) = Delta*c[2], (4) =
Delta*d[2]})) =
(J^T*J)^(-1)*J^T"[[[Delta(f[1])[]],[Delta(f[2])[]],[&vellip;],[Delta f[256]]]]
"" (1.2.5)"
理想的には`&Delta;a`[2], `&Delta;b`[2], `&Delta;c`[2], `&Delta;d`[2]は`&Delta;a`,
`&Delta;b`, `&Delta;c`,
`&Delta;d`に一致するはずだが，測定誤差と高次項のために一致しない．初期値に比べ，より真値に近づくだけ．そこで，新たに得られたパラメータの組を新たな初期
値に用いて，より良いパラメータに近付けていくという操作を繰り返す．新たに得られたパラメータと前のパラメータとの差がある誤差以下になったところで計算を打ち切り，フ
ィッティングの終了となる．
Mapleによる解法の指針
線形代数計算のためにサブパッケージとしてLinearAlgebraを呼びだしておく．
> restart; with(plots): with(LinearAlgebra):
データを読み込む．
> ndata:=8: f1:=t->subs({a1=1,a2=10,a3=1,a4=4},a1+a2/(a3+(t-a4)^2) );
> T:=[seq(f1(i),i=1..ndata)]:
         /                                              a2      \
t -> subs|{a1 = 1, a2 = 10, a3 = 1, a4 = 4}, a1 + --------------|
         |                                                     2|
         \                                        a3 + (t - a4) /
データの表示
> listplot(T,connect=false); l1:=listplot(T,connect=false):

ローレンツ型の関数を仮定し，関数として定義．
> f:=t->a1+a2/(a3+(t-a4)^2); nparam:=4:
                a2      
t -> a1 + --------------
                       2
          a3 + (t - a4) 
ヤコビアンの中の微分を新たな関数として定義．
> for i from 1 to nparam do dfda||i:=unapply(diff(f(x),a||i),x); end do;
x -> 1
           1       
x -> --------------
                  2
     a3 + (x - a4) 
              a2        
x -> - -----------------
                       2
       /             2\ 
       \a3 + (x - a4) / 
       a2 (-2 x + 2 a4) 
x -> - -----------------
                       2
       /             2\ 
       \a3 + (x - a4) / 
初期値を仮定して，データとともに関数を表示．
> g1:=Vector([1,8,1,4.5]): guess1:={}: for i from 1 to nparam do
> guess1:={op(guess1),a||i=g1[i]}; end do: guess1;
> p1:=plot(subs(guess1,f(x)),x=1..ndata): display(l1,p1);
                      {a1 = 1, a2 = 8, a3 = 1, a4 = 4.5}

> interface(displayprecision=3);
> df:=Vector([seq(subs(guess1,T[i]-f(i)),i=1..ndata)]);
3
df := Vector(8, {(1) = .396, (2) = .897, (3) = 2.538, (4) = 3.600, (5) = -1.400,
(6) = -.462, (7) = -.103, (8) = -0.16e-1})
> Jac:=Matrix(ndata,nparam): for i from 1 to ndata do for j from 1 to nparam do
> Jac[i,j]:=evalf(subs(guess1,dfda||j(i))); end do: end do:
> Jac;
Matrix(8, 4, {(1, 1) = 1.000, (1, 2) = 0.75e-1, (1, 3) = -0.46e-1, (1, 4) =
-.319, (2, 1) = 1.000, (2, 2) = .138, (2, 3) = -.152, (2, 4) = -.761, (3, 1) =
1.000, (3, 2) = .308, (3, 3) = -.757, (3, 4) = -2.272, (4, 1) = 1.000, (4, 2) =
.800, (4, 3) = -5.120, (4, 4) = -5.120, (5, 1) = 1.000, (5, 2) = .800, (5, 3) =
-5.120, (5, 4) = 5.120, (6, 1) = 1.000, (6, 2) = .308, (6, 3) = -.757, (6, 4) =
2.272, (7, 1) = 1.000, (7, 2) = .138, (7, 3) = -.152, (7, 4) = .761, (8, 1) =
1.000, (8, 2) = 0.75e-1, (8, 3) = -0.46e-1, (8, 4) = .319})
> tJac:=(MatrixInverse(Transpose(Jac).Jac)).Transpose(Jac);
tJac := Matrix(4, 8, {(1, 1) = .565, (1, 2) = .249, (1, 3) = -.354, (1, 4) =
0.40e-1, (1, 5) = 0.40e-1, (1, 6) = -.354, (1, 7) = .249, (1, 8) = .565, (2, 1)
= -2.954, (2, 2) = -.506, (2, 3) = 4.012, (2, 4) = -.552, (2, 5) = -.552, (2, 6)
= 4.012, (2, 7) = -.506, (2, 8) = -2.954, (3, 1) = -.352, (3, 2) = -0.29e-1, (3,
3) = .557, (3, 4) = -.176, (3, 5) = -.176, (3, 6) = .557, (3, 7) = -0.29e-1, (3,
8) = -.352, (4, 1) = -0.5e-2, (4, 2) = -0.12e-1, (4, 3) = -0.35e-1, (4, 4) =
-0.80e-1, (4, 5) = 0.80e-1, (4, 6) = 0.35e-1, (4, 7) = 0.12e-1, (4, 8) =
0.5e-2})
> g2:=tJac.df; g1:=g1+g2;
g2 := Vector(4, {(1) = -.235, (2) = 5.592, (3) = .613, (4) = -.520})
g1 := Vector(4, {(1) = .765, (2) = 13.592, (3) = 1.613, (4) = 3.980})

これをまたもとの近似値(guess)に入れ直して表示させると以下のようになる．カーブがデータに近づいているのが確認できよう．この操作をずれが十分小さくなるまで繰
り返す．
> guess1:={}: for i from 1 to nparam do guess1:={op(guess1),a||i=g1[i]}; end do:
> guess1; p1:=plot(subs(guess1,f(x)),x=1..ndata): display(l1,p1);
{a1 = 0.765107054282076260, a2 = 13.5919251223407489, a3 = 1.61274649042098117, 

  a4 = 3.98049166112393404}

非線形最小二乗法に関するメモ

このGauss-Newton法と呼ばれる非線形最小二乗法は線形問題から拡張した方法として論理的に簡明であり，広く使われている．しかし，収束性は高くなく，むしろ発
散しやすいので注意が必要．2次の項を無視するのでなく，うまく見積もる方法を用いたのがLevenberg-Marquardt
法である．明快な解説がNumerical Recipes in C(Ｃ 言語による数値計算のレシピ）WilliamH.Press 他著，技術評論社1993
にある．
課題
1 一山ピークへのフィット
以下の256個のデータ
> ndata:=256; f1:=t->subs({a1=10,a2=40000,a3=380,a4=128},a1+a2/(a3+(t-a4)^2) );
> T:=[seq(f1(i)*(0.6+0.8*evalf(rand()/10^12)),i=1..ndata)]:
> f:=t->a1+a2/(a3+(t-a4)^2);
で近似したときのパラメータa1,a2,a3,a4を求めよ．ただし，パラメータの初期値は，ある程度近い値にしないと収束しない．
Mapleによる解法の指針
線形代数計算のためにサブパッケージとしてLinearAlgebraを呼び
だしておく．
> with(LinearAlgebra):
データを読み込む．
> datapoint:=[seq([i,T[i]],i=1..256)]:
ローレンツ型の関数を仮定し，関数として定義．
> f:=a+b/(c+(x-d)^2): f1:=unapply(f,x);
              b      
x -> a + ------------
                    2
         c + (x - d) 
ヤコビアンの中の微分を新たな関数として定義．
> dfda:=unapply(diff(f,a),x): dfdb:=unapply(diff(f,b),x):
> dfdc:=unapply(diff(f,c),x): dfdd:=unapply(diff(f,d),x):
初期値を仮定して，データとともに関数を表示．
> guess1:={a=10,b=1200,c=10,d=125};
> plot([datapoint,subs(guess1,f1(x))],x=1..256);
                     {a = 10, b = 1200, d = 125, c = 10}

解法のヒントと手順
1 (1.2.2)式のΔ f[i]を求めよ．T[i]-f1(i)を1..imaxまで求め，Vectorに入れる．
2 (1.2.3)式のヤコビ行列を求めよ．
3 (1.2.4)式にしたがってヤコビ行列の逆行列を求めよ．また，(1.2.5)式にしたがって新たなパラメータの組を求めよ．
4 求めたパラメータを用いたモデル関数と，データをプロットしてみよ．前回より近づいているのがわかるだろう．
5 上の操作を適当に繰り返し，パラメータを収束させよ．その値とプロットを示せ．
2 二山ピークのフィット
以下のように作成したデータ
> ndata:=256; f1:=t->subs({a=10,b=40000,c=380,d=128},a+b/(c+(t-d)^2) );
> f2:=t->subs({a=10,b=40000,c=380,e=90},a+b/(c+(t-e)^2) );
> T:=[seq((f1(i)+f2(i))*(0.6+0.2*evalf(rand()/10^12)),i=1..ndata)]:
を
> f:=t->a1+a2/(a3+(t-a4)^2)+a2/(a3+(t-a5)^2);
                a2               a2      
t -> a1 + -------------- + --------------
                       2                2
          a3 + (t - a4)    a3 + (t - a5) 
で近似したときのパラメータを求めよ．
> l1:=listplot(T): display(l1);

解答例
> restart; with(plots): with(LinearAlgebra):
> f1:=t->subs({a=10,b=40000,c=380,d=128},a+b/(c+(t-d)^2) );
> f2:=t->subs({a=10,b=40000,c=380,e=90},a+b/(c+(t-e)^2) );
> T:=[seq((f1(i)+f2(i))*(0.6+0.2*evalf(rand()/10^12)),i=1..256)]:
         /                                                b      \
t -> subs|{a = 10, b = 40000, c = 380, d = 128}, a + ------------|
         |                                                      2|
         \                                           c + (t - d) /
         /                                               b      \
t -> subs|{a = 10, b = 40000, c = 380, e = 90}, a + ------------|
         |                                                     2|
         \                                          c + (t - e) /
> writedata("/Users/bob/Desktop/data1",T);
> l1:=listplot(T):
> f:=t->a1+a2/(a3+(t-a4)^2)+a2/(a3+(t-a5)^2); nparam:=5;
                a2               a2      
t -> a1 + -------------- + --------------
                       2                2
          a3 + (t - a4)    a3 + (t - a5) 
                                      5
> for i from 1 to nparam do dfda||i:=unapply(diff(f(x),a||i),x); end do;
                               dfda1 := x -> 1
                                    1                1       
                dfda2 := x -> -------------- + --------------
                                           2                2
                              a3 + (x - a4)    a3 + (x - a5) 
                                   a2                  a2        
            dfda3 := x -> - ----------------- - -----------------
                                            2                   2
                            /             2\    /             2\ 
                            \a3 + (x - a4) /    \a3 + (x - a5) / 
                                      a2 (-2 x + 2 a4) 
                      dfda4 := x -> - -----------------
                                                      2
                                      /             2\ 
                                      \a3 + (x - a4) / 
                                      a2 (-2 x + 2 a5) 
                      dfda5 := x -> - -----------------
                                                      2
                                      /             2\ 
                                      \a3 + (x - a5) / 
> g1:=Vector([10,1200,10,125,90]);
g1 := Vector(5, {(1) = 10, (2) = 1200, (3) = 10, (4) = 125, (5) = 90})
> guess1:={}; for i from 1 to nparam do guess1:={op(guess1),a||i=g1[i]}; end do:
                                 guess1 := {}
> p1:=plot(subs(guess1,f(x)),x=1..256): display(l1);
Error, invalid input: subs received guess1, which is not valid for its 1st
argument

> df:=Vector([seq(subs(guess1,T[i]-f(i)),i=1..256)]):
> Jac:=Matrix(1..256,1..nparam,sparse):
> for i from 1 to 256 do for j from 1 to nparam do
> Jac[i,j]:=evalf(subs(guess1,dfda||j(i))); end do: end do:
> tJac:=(MatrixInverse(Transpose(Jac).Jac)).Transpose(Jac):
> g2:=tJac.df; g1:=g1+g2;
g2 := Vector(5, {(1) = -.390553882992161205, (2) = 1584.55290636967129, (3) =
24.9577909601538366, (4) = -0.472041829705451138e-1, (5) =
-0.719532042503852940e-2})
g1 := Vector(5, {(1) = 13.6348019182603064, (2) = 29567.3667677707381, (3) =
410.545681677467769, (4) = 128.512734548828887, (5) = 90.9223109918718678})
