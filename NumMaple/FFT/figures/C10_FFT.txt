

関数内挿としてのFourier関数系
一連の関数系による関数の内挿は，基底関数をphi[n](x)として
F(x) = sum(a[n]*`&varphi;`[n](x), n = 1 .. N)
(1)
で得られることを見た．
Fourier変換では基底関数として`&varphi;`[n](x) = sin(2*`&pi;nx`),
cos(2*`&pi;nx`)をとる．関数の内挿法で示したように，このx[i]での値f[i], i = `&ctdot;`(1,
M)と，近似の次数(N)とでつくる，

"A=[[[`&varphi;`[0](x[0]),`&varphi;`[1](x[0]),&ctdot;,`&varphi;`[N](x[0])],[&vel
lip;,&vellip;,&vellip;,&vellip;],[`&varphi;`[0](x[M]),`&varphi;`[1](x[M]),&ctdot
;,`&varphi;`[N](x[M])]]]"
とした係数行列を求めて，係数a[i]とデータ点f[i]をそれぞれベクトルと考えると，
A*a = f


から，通常の逆行列を求める手法で係数を決定することもできる．しかし，この強引な方法はデータ数，関数の次数が多い，フーリエ変換が対象としようとする問題では破綻する
．もっといい方法が必要で，それが直交関数系では存在する．
直交関係からの積分による係数決定
関数の直交関係は，
int(`&varphi;`[n](x)*`&varphi;`[m](x), x = a .. b) = delta[mn]*C[n] and
delta[mn]*C[n] = (Vector(2, {(1) = C[m]*at*m = n, (2) = 0 <> n}))
である．C[m]*は
> plot([sin(x),sin(3*x)],x=0..2*Pi);

> plot([sin(x)*sin(3*x)],x=0..2*Pi, color=black);

> int(sin(x)*sin(3*x),x=0..2*Pi);
                                      0
> for i from 1 to 3 do for j from 1 to 3 do S:=int(sin(i*x)*sin(j*x),x=0..2*Pi);
> print(i,j,S); end do; end do:
                                   1, 1, Pi
                                   1, 2, 0
                                   1, 3, 0
                                   2, 1, 0
                                   2, 2, Pi
                                   2, 3, 0
                                   3, 1, 0
                                   3, 2, 0
                                   3, 3, Pi

int(F(x)*`&varphi;`[m](x), x = a .. b)
を考える．先程の(1)式をいれると
"(&int;)[a]^(b)F(x)`&varphi;`[m](x)
&DifferentialD;x=(&int;)[a]^(b)(&sum;)a[n]`&varphi;`[n](x)`&varphi;`[m](x)
&DifferentialD;x=""=[[[(a[m]C)[m] at m=n],[0 at m<>n]]]"
となる．こうして，係数a[n]が
a[n] = (int(F(x)*`&varphi;`[n](x), x = a .. b))/C[n]
で決定できる．
対象とする関数
> restart;
> #F:=x->piecewise(x=0,1/2,x>0,x); #F:=x->piecewise(x<1/2,x,x>=1/2,1-x);
> #F:=x->piecewise(x<1/2,-1,x>1/2,1); F:=x->piecewise(x<1/2,-1,x>=1/2,1);
> #F:=x->piecewise(x>0 and x<1/2,-1,x>1/2,1); #F:=x->x-1/2; plot(F(x),x=0..1);
              /    1      1        \
x -> piecewise|x < -, -1, - <= x, 1|
              \    2      2        /

> KK:=3; N:=2^KK;L:=1-0;
                                      3
                                      8
                                      1
直接積分によるフーリエ級数
> 2*Pi*1/L*x;
                                    2 Pi x
> int(F(x)*cos(2*Pi*1/L*x),x=0..L);
                                      0
> for n from 0 to N do a[n]:=2/L*int(F(x)*cos(2*Pi*n/L*x),x=0..L); end do;
                                      0
                                      0
                                      0
                                      0
                                      0
                                      0
                                      0
                                      0
                                      0
> for n from 0 to N do b[n]:=2/L*int(F(x)*sin(2*Pi*n/L*x),x=0..L); end do;
                                      0
                                       4 
                                     - --
                                       Pi
                                      0
                                       4  
                                    - ----
                                      3 Pi
                                      0
                                       4  
                                    - ----
                                      5 Pi
                                      0
                                       4  
                                    - ----
                                      7 Pi
                                      0
> for n from 0 to N do c[n]:=1/L*int(F(x)*exp(-I*2*Pi*n/L*x),x=0..L); end do;
> for n from 1 to N do c[-n]:=1/L*int(F(x)*exp(I*2*Pi*n/L*x),x=0..L); end do;
Note that: a[n]=c[n]+c[-n], b[n]=I (c[n]-c[-n]) c[-n]= 1/2 (a[n] + b[n]),
c[n]=1/2 (a[n] - I b[n])
                                      0
                                     2 I
                                     ---
                                     Pi 
                                      0
                                     2  
                                     - I
                                     3  
                                     ---
                                     Pi 
                                      0
                                     2  
                                     - I
                                     5  
                                     ---
                                     Pi 
                                      0
                                     2  
                                     - I
                                     7  
                                     ---
                                     Pi 
                                      0
                                      2 I
                                    - ---
                                      Pi 
                                      0
                                      2  
                                      - I
                                      3  
                                    - ---
                                      Pi 
                                      0
                                      2  
                                      - I
                                      5  
                                    - ---
                                      Pi 
                                      0
                                      2  
                                      - I
                                      7  
                                    - ---
                                      Pi 
                                      0
> F1:=unapply(sum(evalf(c[i]*exp(I*2*Pi*i/L*x)),i=-(N-1)..(N-1)),x):
> plot({Re(F1(x)),F(x)},x=0..1);

> evalf(2/3/Pi);
                                 0.2122065907
選点直交性による計算の簡素化
ところが，実際に積分していては，時間がかかりすぎる．直交関数系の選点直交性を使うとより簡単になる．
直交関数系の選点直交性
直交多項式は，
`&varphi;`[n](x) = (0*at)*x and (0*at)*x = x[1], x[2], `&ctdot;`(x[n])
である．n-1以下の次数m, lでは，
sum(phi[l](x[i])*`&varphi;`[m](x[i]), i = 1 .. n) = delta[ml]*C[l]

が成り立つ．これは，直交関係と違い積分でないことに注意．証明は略．
これを使えば，この先程の直交関数展開
F(x) = sum(a[l]*`&varphi;`[l](x), l = 1 .. N)
の両辺に`&varphi;`[m](x[i])を掛けてiについて和をとれば，

"(&sum;)F(x[i])phi[m](x[i])="sum(sum(a[l]*`&varphi;`[l](x[i])*`&varphi;`[m](x[i]
), l = 1 .. N), i = 1 .. n)
=sum(a[l]*(sum(`&varphi;`[l](x[i])*`&varphi;`[m](x[i]), i = 1 .. n)), l = 1 ..
N)
=sum(a[l]*delta[ml]*C[m], l = 1 .. N) = a[m]*C[m]
となる．つまり，
a[m] = (sum(F(x[i])*`&varphi;`[m](x[i]), i = 1 .. n))/C[m]
となり，単純な関数の代入とかけ算で係数が決定される．
選点直交性を用いた結果
> KK:=4; N:=2^KK;L:=1-0;
                                      4
                                      16
                                      1
> for k from 0 to N-1 do c[k]:=evalf(sum(F(i*L/N)*exp(-I*2*Pi*k*i/N),i=0..N-1));
> end do;
                                      0.
                         -2.000000000 + 10.05467898 I
                                      0.
                         -2.000000000 + 2.993211524 I
                                      0.
                         -2.000000001 + 1.336357276 I
                                      0.
                        -2.000000001 + 0.3978247331 I
                                      0.
                        -2.000000001 - 0.3978247331 I
                                      0.
                         -2.000000001 - 1.336357276 I
                                      0.
                         -2.000000000 - 2.993211524 I
                                      0.
                         -2.000000000 - 10.05467898 I
> F1:=unapply(sum(evalf(c[i]*exp(I*2*Pi*i/L*x)/N),i=0..(N/2-1))+
> sum(evalf(c[N-i]*exp(-I*2*Pi*i/L*x)/N),i=1..(N/2-1)),x):
> plot({Re(F1(x)),F(x)},x=0..1);

高速フーリエ変換アルゴリズムによる高速化
sin, cosとexp関数を結びつけるオイラーの関係を使うと，
exp(2*Pi/N*I) = cos(2*Pi/N)+I*sin(2*Pi/N)
と変換できる．これを使うと，
c[k] = (sum(F(x[i])*exp(-2*`&pi;i`/N*I), i = 0 .. N-1))/C[m]
となる．N = 8の場合を実際に計算すると，z = exp(-I*(2*Pi*(1/8)))として，"z^(8)=1, z^(9)=z
&ctdot;"を使うと，

"[[[c[0]],[c[1]],[c[2]],[c[3]],[c[4]],[c[5]],[c[6]],[c[7]]]]=[[[1,1,1,1,1,1,1,1]
,[1,z,z^(2),z^(3),z^(4),z^(5),z^(6),z^(7)],[1,z^(2),z^(4),z^(6),1,z^(2),z^(4),z^
(6)],[1,z^(3),z^(6),z,z^(4),z^(7),z^(2),z^(5)],[1,z^(4),1,z^(4),1,z^(4),1,z^(4)]
,[1,z^(5),z^(2),z^(7),z^(4),z,z^(6),z^(2)],[1, , , , , , , ],[1, , , , , , ,
]]][[[F[0]],[F[1]],[F[2]],[F[3]],[F[4]],[F[5]],[F[6]],[F[7]]]]"
となる．この行列計算を素直に実行すると，8×8=64回の演算が必要となる．これを減らせないかと考えたのが，高速フーリエ変換の始まりである．
この行列をよく見ると同じ計算を重複しておこなっていることが分かる．そこで，行列の左側と右側で同じ計算をしている部分をまとめると，
(Vector(8, {(1) = c[0], (2) = c[1], (3) = c[2], (4) = c[3], (5) = c[4], (6) =
c[5], (7) = c[6], (8) = c[7]})) = Typesetting[delayDotProduct](Matrix(8, 8, {(1,
1) = 1, (1, 2) = 1, (1, 3) = 1, (1, 4) = 1, (1, 5) = 0, (1, 6) = 0, (1, 7) = 0,
(1, 8) = 0, (2, 1) = 0, (2, 2) = 0, (2, 3) = 0, (2, 4) = 0, (2, 5) = 1, (2, 6) =
z, (2, 7) = z^2, (2, 8) = z^3, (3, 1) = 1, (3, 2) = z^2, (3, 3) = z^4, (3, 4) =
z^6, (3, 5) = 0, (3, 6) = 0, (3, 7) = 0, (3, 8) = 0, (4, 1) = 0, (4, 2) = 0, (4,
3) = 0, (4, 4) = 0, (4, 5) = 1, (4, 6) = z^3, (4, 7) = z^6, (4, 8) = z, (5, 1) =
1, (5, 2) = z^4, (5, 3) = 1, (5, 4) = z^4, (5, 5) = 0, (5, 6) = 0, (5, 7) = 0,
(5, 8) = 0, (6, 1) = 0, (6, 2) = 0, (6, 3) = 0, (6, 4) = 0, (6, 5) = 1, (6, 6) =
z^5, (6, 7) = z^2, (6, 8) = z^7, (7, 1) = 1, (7, 2) = z^6, (7, 3) = z^4, (7, 4)
= z^2, (7, 5) = 0, (7, 6) = 0, (7, 7) = 0, (7, 8) = 0, (8, 1) = 0, (8, 2) = 0,
(8, 3) = 0, (8, 4) = 0, (8, 5) = 1, (8, 6) = z^7, (8, 7) = z^6, (8, 8) = z^5}),
Vector(8, {(1) = F[0]+F[4], (2) = F[1]+F[5], (3) = F[2]+F[6], (4) = F[3]+F[7],
(5) = F[0]-F[4], (6) = F[1]-F[5], (7) =
`#msub(mi("F"),mrow(mo("&quest;"),mo("&quest;")))`-F[6], (8) =
`#msub(mi("F"),mrow(mo("&quest;"),mo("&quest;")))`-F[7]}), true)
とすることができる．ここで，z^4 =
-1などを使っている．右側のベクトルの計算でロスするが，行列の中の計算の回数を半分に減らすことができる．再度できあがった行列を見れば，同じ計算をさらにまとめるこ
とができそうである．こうして，次々と計算回数を減らしていくことが可能で，最終的に行列部分の計算が一切なくなる．残るのは，右側のベクトルの足し算引き算だけになる．

このベクトルの組み合わせは，一見相当複雑そうで，その条件分岐で時間がかかりそうに思われる．しかし，よく調べてみれば，単純なビット演算で処理することが可能であるこ
とが判明した．こうして，2の整数乗のデータの組に対しては，極めて高速にフーリエ変換を実行することが可能となった．
FFTでの演算回数は，データ数をNとすると
N*log[2]*N
となる．単純な場合のN^2と比較すると，以下のようになり，どれだけ高速化されているかが理解されよう．

> dN2:=[]; dFft:=[]; for i from 2 to 16 do N:=2^i; n2:=N*N; Fft:=N/2*log[2](N);
> Fft/n2; printf("%10d %12d %12d %10.5f\n",N,n2,Fft,evalf(Fft/n2));
> dN2:=[op(dN2),[N,n2]]; dFft:=[op(dFft),[N,Fft]]; end do:
                                      []
                                      []
4 16 4 0.25000 8 64 12 0.18750 16 256 32 0.12500 32 1024 80 0.07812 64 4096 192
0.04688 128 16384 448 0.02734 256 65536 1024 0.01562 512 262144 2304 0.00879
1024 1048576 5120 0.00488 2048 4194304 11264 0.00269 4096 16777216 24576 0.00146
8192 67108864 53248 0.00079 16384 268435456 114688 0.00043 32768 1073741824
245760 0.00023 65536 4294967296 524288 0.00012
> with(plots):
> l1:=plot(dN2): l2:=plot(dFft):
> display(l1,l2);

> l1:=logplot(dN2): l2:=logplot(dFft):
> display(l1,l2);

> l1:=loglogplot(dN2): l2:=loglogplot(dFft):
> display(l1,l2);

FFT関数を用いた結果
> KK:=3; N:=2^KK;i:='i'; x1:=array([evalf(seq(F(i/N),i=0..N-1))]);
> y1:=array([evalf(seq(0,i=0..N-1))]);
KK := 3
N := 8
i := i
x1 := Vector[row](8, {(1) = -1., (2) = -1., (3) = -1., (4) = -1., (5) = 1., (6)
= 1., (7) = 1., (8) = 1.})

> FFT(KK,x1,y1);
                                      8
> print(x1);print(y1);
Vector[row](8, {(1) = 0., (2) = -2.000000001, (3) = 0., (4) = -1.999999999, (5)
= 0., (6) = -1.999999999, (7) = 0., (8) = -2.000000001})
                                      y1
> F2:=unapply(sum(evalf((x1[i]+I*y1[i])*exp(I*2*Pi*(i-1)/L*x)/N),i=1..N/2)+
> sum(evalf((x1[N-i+2]+I*y1[N-i+2])*exp(-I*2*Pi*(i-1)/L*x)/N),i=2..N/2),x):
> plot({Re(F2(x)),F(x)},x=0..1);

