線形最小2乗法
ー数値計算(11/12/2)ー
関西学院大学理工学部 西谷滋人
Copyright @2007-11 by Shigeto R. Nishitani
最乗2乗法の原理

前回の授業では，データに多項式を完全にフィットする補間についてみた．今回は，近似的にフィットする最小二乗法について詳しくみていく．図のようなデータに直線をフィッ
トする場合を考えよう．
 <n! 
        

コマンドleastsquareによるfitting(2変数の例)
> restart: X:=[1,2,3,4]: Y:=[0,5,15,24]:
> with(plots):with(linalg):with(stats):
> l1:=pointplot(transpose([X,Y]),symbolsize=30):
> eq_fit:=fit[leastsquare[[x, y], y = a0+a1*x, {a0,a1}]]([X, Y]);
                                     19   41  
                               y = - -- + -- x
                                     2    5   
> f1:=unapply(rhs(eq_fit),x);
       19   41  
x -> - -- + -- x
       2    5   
> p1:=plot(f1(x),x=0..4):
> display(p1,l1);

最小2乗法の原理
もっとも簡単な例で原理を解説する．近似関数として，
F(x) = a[0]+a[1]*x
という直線近似を考える．もっともらしい関数はN点の測定データとの差d[i] =
F(x[i])-y[i]を最小にすればよさそうであるが，これはプラスマイナスですぐに消えて不定になる．そこで，
"chi^(2)=(&sum;)d[i]^(2)=(&sum;)(a[0]+a[1]x[i]-y[i])^(2)"
という関数を考える．このchi^2(カイ二乗)関数が，a[0], a[1]をパラメータとして変えた時に最小となるa[0],
a[1]を求める．これは，それらの微分がそれぞれ0となる場合である．これはchi^2の和"&sum;"(sum)の中身を展開し，
 "chi^(2)=" 
a[0], a[1]でそれぞれ微分すれば
 "(&PartialD;)/(&PartialD; a[0]) chi^(2)=" 

 "(&PartialD;)/(&PartialD; a[1]) chi^(2)=" 


というa[0], a[1]を未知変数とする2元の連立方程式が得られる．これは前に説明した通り逆行列で解くことができる．
χ2乗の極小値から(2変数の例)
> restart; X:=[1,2,3,4]: Y:=[0,5,15,24]: f1:=x->a0+a1*x:
> S:=0; for i from 1 to 4 do S:=S+(f1(X[i])-Y[i])^2; end do:
                                      0
> fS:=unapply(S,(a0,a1));
                             2                  2                   2
        (a0, a1) -> (a0 + a1)  + (a0 + 2 a1 - 5)  + (a0 + 3 a1 - 15) 

                             2
           + (a0 + 4 a1 - 24) 
> expand(fS(a0,a1));
                   2                   2                       
               4 a0  + 20 a0 a1 + 30 a1  - 88 a0 - 302 a1 + 826
> plot3d(fS(a0,a1),a0=-20..20,a1=0..20);

> eqs:={diff(expand(S),a0)=0, diff(expand(S),a1)=0};
               {8 a0 + 20 a1 - 88 = 0, 20 a0 + 60 a1 - 302 = 0}
> solve(eqs,{a0,a1});
                             /     41       -19\ 
                            { a1 = --, a0 = --- }
                             \     5         2 / 
> 
正規方程式による解
より一般的な場合の最小二乗法の解法を説明する．先程の例では1次の多項式を近似関数とした．これをより一般的な関数，例えば，sin, cos, tan, exp,
sinhなどとする．これを線形につないだ関数を
"F(X)=a[0]sin(x)+a[1]cos(x)+a[2]exp(-x)+a[3]sinh(x)+&ctdot;=(&sum;)a[k]X[k](x)"
ととる．実際には，X[k](x)はモデルや，多項式の高次項など論拠のある関数列をとる．これらを基底関数(base
functions)と呼ぶ．ここで線形といっているのは，パラメータa[k]について線形という意味である．この応用を次節で取り上げる．
このような，より一般的な基底関数を使っても，chi^2関数は
chi^2 = sum((F(x[i])-y[i])^2, i = 1 .. N)=sum((sum(a[k]*X[k](x[i]), k = 1 ..
M)-y[i])^2, i = 1 .. N)

と求めることができる．この関数を，a[k]を変数とする関数とみなす．この関数が最小値を取るのは，chi^2をM個のa[k]で偏微分した式がすべて0となる場合であ
る．これは
sum((sum(a[j]*X[j](x[i]), j = 1 .. M)-y[i])*X[k](x[i]), i = 1 .. N) = 0

ここで，k = 1, () .. (), MのM個の連立方程式である．この連立方程式を最小二乗法の正規方程式(normal equations)と呼ぶ．

上記の記法のままでは，ややこしいので，行列形式で書き直す．`&x`(N, M)で，各要素を
A[ij] = X[j](x[i])
とする行列Aを導入する．この行列は，

"A=[[[X[1](x[1]),X[2](x[1]),&ctdot;,X[M](x[1])],[,,&ctdot;,],[,,&ctdot;,],[,,&ve
llip;,],[,,&vellip;,],[,,&ctdot;,],[,,,],[,,,]]]"
となる．これをデザイン行列と呼ぶ．すると先程の正規方程式は，
A^T*A*a = A^T*y
で与えられる．A^Tは行列Aの転置(transpose)を意味し，得られた行列は，`&x`(M, N)である．"a,"yはそれぞれ，
"a=[[[a[1]],[a[2]],[&vellip;],[a[M]]]], y=[[[y[1]],[y[2]],[&vellip;],[y[N]]]]"
である．M = 3, N = 25として行列の次元だけで表現すると，
"[[[,,,&ctdot;,],[&ctdot;,&ctdot;,&ctdot;,&ctdot;,&ctdot;],[,,,&ctdot;,]]]
[[[,&ctdot;,],[,&vellip;,],[&vellip;,&vellip;,&vellip;],[,&vellip;,],[,&vellip;,
]]]"" [[[&vellip;],[&vellip;],[&vellip;]]] =
[[[,,,&ctdot;,],[&ctdot;,&ctdot;,&ctdot;,&ctdot;,&ctdot;],[,,,&ctdot;,]]]
[[[*],[*],[*],[*],[*]]] "
となる．これは少しの計算で3*3の逆行列を解く問題に変形できる．
正規方程式(normal equations)
> restart; X:=[1,2,3,4]: Y:=[0,5,15,24]: f1:=x->a[1]+a[2]*x+a[3]*x^2:
> with(LinearAlgebra): Av:=Matrix(1..4,1..3):
> ff:=(x,i)->x^(i-1); for i from 1 to 3 do for j from 1 to 4 do
> Av[j,i]:=ff(X[j],i); end do; end do; Av;
                                            (i - 1)
                           ff := (x, i) -> x       
Matrix(4, 3, {(1, 1) = 1, (1, 2) = 1, (1, 3) = 1, (2, 1) = 1, (2, 2) = 2, (2, 3)
= 4, (3, 1) = 1, (3, 2) = 3, (3, 3) = 9, (4, 1) = 1, (4, 2) = 4, (4, 3) = 16})
> Ai:=MatrixInverse(Transpose(Av).Av);
Ai := Matrix(3, 3, {(1, 1) = 31/4, (1, 2) = -27/4, (1, 3) = 5/4, (2, 1) = -27/4,
(2, 2) = 129/20, (2, 3) = -5/4, (3, 1) = 5/4, (3, 2) = -5/4, (3, 3) = 1/4})
> b:=Transpose(Av).Vector(Y);
b := Vector(3, {(1) = 44, (2) = 151, (3) = 539})
> Ai.b;
Vector(3, {(1) = -9/2, (2) = 16/5, (3) = 1})
特異値分解(Singular Value Decomposition)
正規方程式での共分散行列,特異値分解の導出や標準偏差との関係はNumRecipeを参照せよ．
> restart; X:=[1,2,3,4]: Y:=[0,5,15,24]: f1:=x->a[1]+a[2]*x+a[3]*x^2:
> with(LinearAlgebra): Av:=Matrix(1..4,1..3):
> ff:=(x,i)->x^(i-1): for i from 1 to 3 do for j from 1 to 4 do
> Av[j,i]:=ff(X[j],i); end do; end do; Av;
Matrix(4, 3, {(1, 1) = 1, (1, 2) = 1, (1, 3) = 1, (2, 1) = 1, (2, 2) = 2, (2, 3)
= 4, (3, 1) = 1, (3, 2) = 3, (3, 3) = 9, (4, 1) = 1, (4, 2) = 4, (4, 3) = 16})
> U,S,Vt:=evalf(SingularValues(Av,output=['U','S','Vt'])):
> DiagonalMatrix(S[1..3],4,3); U.DiagonalMatrix(S[1..3],4,3).Vt:
Matrix(4, 3, {(1, 1) = 19.6213640200000015, (1, 2) = 0, (1, 3) = 0, (2, 1) = 0,
(2, 2) = 1.71206987399999999, (2, 3) = 0, (3, 1) = 0, (3, 2) = 0, (3, 3) =
.266252879300000022, (4, 1) = 0, (4, 2) = 0, (4, 3) = 0})
> iS:=Vector(3): for i from 1 to 3 do iS[i]:=1/S[i]; end do:
> DiS:=DiagonalMatrix(iS[1..3],3,4);
DiS := Matrix(3, 4, {(1, 1) = 0.5096485642e-1, (1, 2) = 0, (1, 3) = 0, (1, 4) =
0, (2, 1) = 0, (2, 2) = .5840883104, (2, 3) = 0, (2, 4) = 0, (3, 1) = 0, (3, 2)
= 0, (3, 3) = 3.755827928, (3, 4) = 0})
> Transpose(Vt).DiS.(Transpose(U).Vector(Y));
Vector(3, {(1) = -4.50000000198176498, (2) = 3.20000000035008324, (3) =
1.00000000040565196})
2次元曲面へのフィット
先程の一般化をより発展させると，3次元(x[i], y[i],
z[i])で提供されるデータへの，2次元平面でのフィットも可能となる．2次元の単純な曲面は，方程式を使って，
F(x, y) = a[1]+a[2]*x+a[3]*y+a[4]*xy+a[5]*x^2+a[6]*y^2
となる．デザイン行列のi行目の要素は，
[1, x[i], y[i], x[i]*y[i], x[i]^2, y[i]^2]

として，それぞれ求める．このデータの変換の様子をMapleスクリプトで詳しく示した．後は，通常の正規方程式を解くようにすれば，このデータを近似する曲面を定めるパ
ラメータa[1], a[2], `&ctdot;`(a[6])が求まる．最小二乗法はパラメータa[k]について線形であればよい．

xy平面への応用
実際のデータ解析での例．データの座標をx,y,zで用意して，Mapleの埋め込み関数のleastsquareでfitしている．
> with(plots):with(plottools): z:=[0.000046079702088, 0.000029479057275,
> 0.000025769637830, 0.000034951410953, 0.000057024385455, 0.000029485453808,
> 0.000011519913869, 0.000006442404299, 0.000014252898382, 0.000034951410953,
> 0.000025769637773, 0.000006442404242, 0.000000000000057, 0.000006442404242,
> 0.000025769637773, 0.000034932221524, 0.000014246501905, 0.000006442404299,
> 0.000011519913926, 0.000029479057332, 0.000056973214100, 0.000034932221467,
> 0.000025769637773, 0.000029485453808, 0.000046079702031]:
> x:=[]: y:=[]: p1:=2: for i from -p1 to p1 do for j from -p1 to p1 do
> x:=[op(x),i*0.0005]; y:=[op(y),j*0.0005]; end do; end do;
> with(LinearAlgebra): p2:=convert(Transpose(Matrix([x,y,z])),listlist):
> pp2:=pointplot3d(p2,symbol=circle,symbolsize=30,color=black):
> with(stats): data:=[x,y,z]: fit1:=fit[leastsquare[[t,s,u],
> u=a+b*t+c*s+d*t*s+e*t^2+f*s^2, {a,b,c,d,e,f}]](data);
                         -13                                            
      u = -8.657142857 10    - 0.000006396456800 t + 0.000006396438400 s

                                          2                2
         - 5.459553587 t s + 25.76962838 t  + 25.76962835 s 
> f1:=unapply(rhs(fit1),(s,t)):
> pf1:=plot3d(f1(ss,uu),ss=-0.001..0.001,uu=-0.001..0.001,color=gray):
> display(pf1,pp2);

正規方程式による解法
デザイン行列へのデータ変換
> bb:=Vector(25): A:=Matrix(25,6): p1:=2: for i from 1 to 25 do A[i,1]:=1;
> A[i,2]:=x[i]; A[i,3]:=y[i]; A[i,4]:=x[i]*y[i]; A[i,5]:=x[i]^2; A[i,6]:=y[i]^2;
> bb[i]:=z[i]; end do:
正規方程式の解
> MatrixInverse(Transpose(A).A).(Transpose(A).bb);
Vector(6, {(1) = -0.9185257196e-12, (2) = -0.639644675999994798e-5, (3) =
0.639644220000032532e-5, (4) = -5.45955358336000173, (5) = 25.7696284050857187,
(6) = 25.7696284050857543})
> 
課題
1 1次元の線形最小二乗法
次の4点のデータをy = a[1]+a[2]*x+a[3]*x^2で近似せよ(2006年度期末試験)．
X:=[0,1,2,3];
Y:=[1,3,4,10];
2 2次元の最小二乗フィット
以下のデータを
f(x, y) = a[1]+a[2]*x+a[3]*y+a[4]*xy
で近似せよ
x, y, z
-1, -1, 2.00000
-1, 0, 0.50000
-1, 1, -1.00000
0, -1, 0.50000
0, 0, 1.00000
0, 1, 1.50000
1, -1, -1.00000
1, 0, 1.50000
1, 1, 4.00000
