補間(interpolation)


Newton(ニュートン) の内挿公式
Newton(ニュートン) の内挿公式は，
"F(x)=F(x[0])+(x-x[0])f[1][x[0]-x[1]]+(x-x[0])(x-x[1])f[2][x[0],x[1],x[2]]+"
⋯+"(&prod;)(x-x[i])f[N][x[0],x[1],&ctdot;,x[N]]"
となる．ここでf[n][] は次のような関数を意味していて，

f[1][x[0], x[1]] = (y[0]-y[1])/(x[0]-x[1])
f[2][x[0], x[1], x[2]] = (f[1][x[0], x[1]]-f[1][x[1], x[2]])/(x[0]-x[2])
⋮

"f[N][x[0],x[1],&ctdot;,x[n]]=(f[N][x[0],x[1],&ctdot;,x[n-1]]-f[N][x[0],x[1],&ct
dot;,x[n]])/(x[0]-x[n])"
差分商と呼ばれる．得られた多項式は，Lagrange の内挿公式で得られたものと当然一致する．
ニュートンの補間公式の導出
関数F(x)をxの多項式として展開．その時の，係数の取るべき値と，差商公式で得られる値が一致．
> restart: F:=x->f0+(x-x0)*f1p+(x-x0)*(x-x1)*f2p;
x -> f0 + (x - x0) f1p + (x - x0) (x - x1) f2p
> F(x1); s1:=solve(F(x1)=f1,f1p);
                              f0 + (x1 - x0) f1p
                                   f0 - f1 
                                   --------
                                   -x1 + x0
f20の取るべき値の導出
> s2:=solve(F(x2)=f2,f2p); fac_f2p:=factor(subs(f1p=s1,s2));
                           f0 + f1p x2 - f1p x0 - f2
                         - -------------------------
                             (-x2 + x0) (-x2 + x1)  
                f0 x1 - x2 f0 + x2 f1 - x0 f1 - f2 x1 + f2 x0
                ---------------------------------------------
                      (-x1 + x0) (-x2 + x0) (-x2 + x1)       
ニュートンの差分商公式を変形
> ff11:=(f0-f1)/(x0-x1); ff12:=(f1-f2)/(x1-x2); ff2:=(ff11-ff12)/(x0-x2);
> fac_newton:=factor(ff2);
                                   f0 - f1 
                                   --------
                                   -x1 + x0
                                   f1 - f2 
                                   --------
                                   -x2 + x1
                             f0 - f1    f1 - f2 
                             -------- - --------
                             -x1 + x0   -x2 + x1
                             -------------------
                                  -x2 + x0      
                f0 x1 - x2 f0 + x2 f1 - x0 f1 - f2 x1 + f2 x0
                ---------------------------------------------
                      (-x1 + x0) (-x2 + x0) (-x2 + x1)       
二式が等しいかどうかをevalbで判定
> evalb(fac_f2p=fac_newton);
                                     true
> 
数値積分 (Numerical integration)
積分，
I = int(f(x), x = a .. b)
を求めよう．1次元の数値積分法では連続した領域を細かい短冊に分けて，それぞれの面積を寄せ集めることに相当する．分点の数を N とすると，
x[i] = a+(b-a)*i/N and a+(b-a)*i/N = a+`&x`(h, i)
h = (b-a)/N
ととれる．そうすると，もっとも単純には，
I[N] = {sum(f(x[i]), i = 0 .. N-1)}*h and {sum(f(x[i]), i = 0 .. N-1)}*h =
{sum(f(a+`&x`(i, h)), i = 0 .. N-1)}*h
となる．
 p$Mn! 
          
中点則 (midpoint rule)
中点法 (midpoint rule) は，短冊を左端から書くのではなく，真ん中から書くことに対応し，
I[N] = {sum(f(a+`&x`(i+1/2, h)), i = 0 .. N-1)}*h
となる．
台形則 (trapezoidal rule)
さらに短冊の上側を斜めにして，短冊を台形にすれば精度が上がりそうに思う．
その場合は，短冊一枚の面積S[i]は，
S[i] = ((f(x[i])+f(x[i+1]))*(1/2))*h
で求まる．これを端から端まで加えあわせると，
I[N] = sum(S[i], i = 0 .. N-1) and sum(S[i], i = 0 .. N-1) =
h*{(1/2)*f(x[0])+sum(f(x[i]), i = 1 .. N-1)+(1/2)*f(x[N])}
が得られる．
Simpson(シンプソン) 則
Simpson(シンプソン) 則では，短冊を 2 次関数，
f(x) = ax^2+bx+c
で近似することに対応する．こうすると，
S[i] = int(f(x), x = x[i] .. x[i+1]) and int(f(x), x = x[i] .. x[i+1]) =
int(ax^2+bx+c, x = x[i] .. x[i+1])
  

(1/6)*h*{f(x[i])+4*f(x[i]+(1/2)*h)+f(x[i]+h)}

となる．これより，
I[N] = (1/6)*h*{f(x[0])+4*(sum(f(x[i]+(1/2)*h), i = 0 .. N-1))+2*(sum(f(x[i]), i
= 1 .. N-1))+f(x[N])}
として計算できる．ただし，関数値を計算する点は台形則などの倍となっている．

教科書によっては，分割数 N を偶数にかぎって，点を偶数番目 (even) と奇数番目 (odd) に分
けて，
I[N] = (1/3)*h*{f(x[0])+4*(sum(f(x[i]+(1/2)*h), i = even ..
N-2))+2*(sum(f(x[i]), i = odd .. N-1))+f(x[N])}
としているテキストもあるが，同じ計算になるので誤解せぬよう．
Derivation of Simpson's rule
> restart; f:=x->a*x^2+b*x+c; e1:=expand(subs(x1=x0+h,int(f(x),x=x0..x1)));
        2          
x -> a x  + b x + c
                  2           2   1    3            1    2      
              a x0  h + a x0 h  + - a h  + b x0 h + - b h  + c h
                                  3                 2           
> e2:=expand(h/6*(f(x0)+4*f(x0+h/2)+f(x0+h)));
                  2           2   1    3            1    2      
              a x0  h + a x0 h  + - a h  + b x0 h + - b h  + c h
                                  3                 2           
> evalb(e1=e2);
                                     true
Numerical integration
> restart; f1:=x->4/(1+x^2); plot(f1(x),x=0..5);
       4   
x -> ------
          2
     1 + x 

> int(f1(x),x=0..1);
                                      Pi
> int(1/(1+x^2),x);
                                  arctan(x)
> N:=8: x0:=0: xn:=1: Digits:=20:
Midpoint rule(中点法)
> h:=(xn-x0)/N: S:=0: for i from 0 to N-1 do xi:=x0+(i+1/2)*h; dS:=h*f1(xi);
> S:=S+dS; end do: evalf(S);
                            3.1428947295916887799
Trapezoidal rule(台形公式)
> h:=(xn-x0)/N: S:=f1(x0)/2: for i from 1 to N-1 do xi:=x0+i*h; dS:=f1(xi);
> S:=S+dS; end do: S:=S+f1(xn)/2: evalf(h*S);
                            3.1389884944910890093
Simpson's rule(シンプソンの公式)
> M:=N/2: h:=(xn-x0)/(2*M): Seven:=0: Sodd:=0: for i from 1 to 2*M-1 by 2 do
> xi:=x0+i*h; Sodd:=Sodd+f1(xi); end do: for i from 2 to 2*M-1 by 2 do
> xi:=x0+i*h; Seven:=Seven+f1(xi); end do:
> evalf(h*(f1(x0)+4*Sodd+2*Seven+f1(xn))/3);
                            3.1415925024587069144
課題
1 補間と近似の違いについて，適切な図を描いて説明せよ．
2 多項式補間
次の4点
x y 0 1 1 2
2 3
3 -2
を通る多項式を以下のそれぞれの手法で求めよ．
(a) 逆行列
(b)ラグランジュ補間
(c)ニュートンの差分商公式　
3 tan(5"^(..)")=0.8748866355e-1, tan(10"^(..)")=.1763269807,
tan(15"^(..)")=.2679491924の値を用いて，ラグランジュ補間法により，tan(`#msup(mn("17"),mo("&compfn;")
)`)の値を推定せよ．(2008年度期末試験）
4 exp(0)=1.0, exp(0.1)=1.1052,
exp(0.3)=1.3499の値を用いて，ラグランジュ補間法により，exp(0.2)の値を推定せよ．(2009年度期末試験）
5 次の関数
f(x) = 4/(1+x^2)
をx = 0 .. 1で数値積分する．
（１）Nを2,4,8,…256ととり，N個の等間隔な区間にわけて中点法で求めよ．(15)
（２）小数点以下10桁まで求めた値3.141592654との差をdXとする．dXと分割数Nとを両対数プロット(loglogplot)して比較せよ(10)
(2008年度期末試験）
6 次の関数
y = 1/(1+x^2)
をx = `&ctdot;`(0, 1)で等間隔にN+1点とり，N個の区間にわけて数値積分で求める．Nを2, 4, 8, 16, 32, 64, 128,
256と取ったときのそれぞれの手法の収束性を比較せよ．
(a)中点法
(b)台形公式
(c)シンプソン公式
ヒント：Maple script にあるそれぞれの数値積分法を関数 (procedure) に直して，for-loop
で回せば楽．出来なければ，一つ一つ手で変えても OK. 両対数プロット (loglogplot) すると見やすい．
