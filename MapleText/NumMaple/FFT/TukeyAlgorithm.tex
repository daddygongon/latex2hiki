$\sin, \cos$と$\exp$関数を結びつけるオイラーの関係を使うと，
\begin{equation*}
{\exp\left({\frac {2\pi}{N}}I\right)}=\cos \left({\frac { 2\,\pi }{N}} \right) +I\,\sin \left( {\frac {2\,\pi }{N}} \right) \end{equation*}
と変換できる．これを使うと，
\begin{equation*}
c_{{k}}=\frac{1}{C_{{m}}}\sum _{i=0}^{N-1}F \left( x_{{i}} \right) {{\exp}\left({{\frac {-2\,\pi I}{N}}}\right)}
\end{equation*}
となる．$N = 8$の場合を実際に計算すると，$\displaystyle z = \exp(-\frac{2\pi}{8}I)$として，$z^8=1,z^9=z, \cdots$を使うと，
\begin{equation*}
\left[\begin{array}{c}
c_0\\c_1\\c_2\\c_3\\c_4\\c_5\\c_6\\c_7
\end{array}\right] =
\left[\begin{array}{cccccccc}
1&1&1&1&1&1&1&1\\
1&z&z^2&z^3&z^4&z^5&z^6&z^7\\
1&z^2&z^4&z^6&1&z^2&z^4&z^6\\
1&z^3&z^6&z&z^4&z^7&z^2&z^5\\
1&z^4&1&z^4&1&z^4&1&z^4\\
1&z^5&z^2&z^7&z^4&z^1&z^6&z^3\\
\vdots & & & & & & &  \\
\vdots & & & & & & & 
\end{array}\right]
\left[\begin{array}{c}
F_0\\F_1\\F_2\\F_3\\F_4\\F_5\\F_6\\F_7
\end{array}\right]
\end{equation*}
となる．この行列計算を素直に実行すると，8×8=64回の演算が必要となる．これを減らせないかと考えたのが，高速フーリエ変換の始まりである．
この行列をよく見ると同じ計算を重複しておこなっていることが分かる．そこで，行列の左側と右側で同じ計算をしている部分をまとめると，
\begin{equation*}
\left[\begin{array}{c}
c_0\\c_1\\c_2\\c_3\\c_4\\c_5\\c_6\\c_7
\end{array}\right] =
\left[\begin{array}{cccccccc}
1&1&1&1&0&0&0&0\\
0&0&0&0&1&z&z^2&z^3\\
1&z^2&z^4&z^6&0&0&0&0\\
0&0&0&0&1&z^3&z^6&z\\
1&z^4&1&z^4&0&0&0&0\\
0&0&0&0&1&z^5&z^2&z^7\\
1&z^6&z^4&z^2&0&0&0&0\\
0&0&0&0&1&z^7&z^6&z^5\\
\end{array}\right]
\left[\begin{array}{c}
F_0+F_4\\F_1+F_5\\F_2+F_6\\F_3+F_7\\F_0-F_4\\F_1-F_5\\F_{[ \,\,]}-F_6\\F_{[\,\,]}-F_7
\end{array}\right]
\end{equation*}
とすることができる．ここで，$z^4 =-1$などを使っている．右側のベクトルの計算でロスするが，行列の中の計算の回数を半分に減らすことができる．再度できあがった行列を見れば，同じ計算をさらにまとめるこ
とができそうである．こうして，次々と計算回数を減らしていくことが可能で，最終的に行列部分の計算が一切なくなる．残るのは，右側のベクトルの足し算引き算だけになる．

このベクトルの組み合わせは，一見相当複雑そうで，その条件分岐で時間がかかりそうに思われる．しかし，よく調べてみれば，単純なビット演算で処理することが可能であるこ
とが判明した．こうして，2の整数乗のデータの組に対しては，極めて高速にフーリエ変換を実行することが可能となった．
FFTでの演算回数は，データ数をNとすると
\begin{equation*}
N\log_2 N
\end{equation*}
となる．単純な場合の$N^2$と比較すると，以下のようになり，どれだけ高速化されているかが理解されよう．
\begin{MapleInput}
> dN2:=[]; dFft:=[]; for i from 2 to 16 do N:=2^i; n2:=N*N; Fft:=N/2*log[2](N);
> Fft/n2; printf("%10d %12d %12d %10.5f\n",N,n2,Fft,evalf(Fft/n2));
> dN2:=[op(dN2),[N,n2]]; dFft:=[op(dFft),[N,Fft]]; end do:
\end{MapleInput}
\begin{MapleError}
         4           16            4    0.25000
         8           64           12    0.18750
        16          256           32    0.12500
        32         1024           80    0.07812
        64         4096          192    0.04688
       128        16384          448    0.02734
       256        65536         1024    0.01562
       512       262144         2304    0.00879
      1024      1048576         5120    0.00488
      2048      4194304        11264    0.00269
      4096     16777216        24576    0.00146
      8192     67108864        53248    0.00079
     16384    268435456       114688    0.00043
     32768   1073741824       245760    0.00023
     65536   4294967296       524288    0.00012
\end{MapleError}
\begin{MapleInput}
> with(plots):
> l1:=plot(dN2): l2:=plot(dFft):
> display(l1,l2);
\end{MapleInput}
\MaplePlot{50mm}{./figures/C10_FFTplot2d14.eps}

\begin{MapleInput}
> l1:=logplot(dN2): l2:=logplot(dFft):
> display(l1,l2);
\end{MapleInput}
\MaplePlot{50mm}{./figures/C10_FFTplot2d15.eps}

\begin{MapleInput}
> l1:=loglogplot(dN2): l2:=loglogplot(dFft):
> display(l1,l2);
\end{MapleInput}
\MaplePlot{50mm}{./figures/C10_FFTplot2d16.eps}
