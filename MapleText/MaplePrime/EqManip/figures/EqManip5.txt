式の変形(IV, 基本と奥の手)
解説

どうしても解かなければならない課題を前にコマンドリファレンスのあちこちを参照しながら解いていくのが数式処理を修得する最速法である．とびかかる前にちょっとした共通
のコツがある．それをここでは示す．数式処理ソフトでの数式処理とは，数式処理ソフトが『自動的にやって』くれるのではなく，実際に紙と鉛筆で解いていく手順を数式処理ソ
フトに『やらせる』ことであることを肝に銘じよ．
鉄則
Mapleをはじめとする数式処理ソフトの習得にあたって初心者がつまづく共通の過ちを回避する鉄則がある．
鉄則０：restart をかける

続けて入力すると前の入力が生きている．違う問題へ移るときや，もう一度入力をし直すときには，restart;を入力して初期状態からはじめる．入力した順番が狂ってい
る場合もある．頭から順にreturnをやり直す．
鉄則１：出力してみる

多くのテキストではページ数の関係で出力を抑止しているが，初心者が問題を解いていく段階ではデータやグラフをできるだけ多く出力する．最後のコロンをセミコロンに変える
，あるいは途中にprint文を入れる．
鉄則２：関数に値を代入してみる
数値が返ってくるべき時に変数があればどこかで入力をミスっている．plotで以下のようなエラーが出た場合にチェック．
> plot(f(x),x);
Warning, unable to evaluate the function to numeric values in the region; see
the plotting command's help page to ensure the calling sequence is correct
鉄則３：内側から順に入力する

長い入力やfor-loopを頭から打ち込んではいけない！！　内側から順に何をしているか解読・確認しながら打ち込む．括弧が合わなかったり，読み飛ばしていたりという
エラーが回避できる．
具体例：無限積分
以下に示す積分を実行せよ．
int(x*e^(-`&beta;c`*x^2)*(1+`&beta;g`*x^3), x = -infinity .. infinity)
最新版のMapleでは改良が施されていて，このような複雑な積分も一発で求まる．
> f1:=unapply(x*exp(-beta*c*x^2)*(1+beta*g*x^3),x);
          /         2\ /            3\
x -> x exp\-beta c x / \1 + beta g x /
> int(f1(x),x=-infinity..infinity);
piecewise(csgn(c*beta) = 1, (3/4)*sqrt(Pi)*g/(beta*c^2*sqrt(c*beta)), infinity)
ここでは，beta,cが正の場合(csgn(beta
c)=1)とそれ以外の場合(otherwise)に分けて答えを返している．しかしこのような意図したきれいな結果をいつもMapleが返してくれるとは限らない．これ
だけしか知らないと，なにかうまくいかないときにお手上げになってしまう．このようなきれいで簡単な結果に行き着く前の，裏でおこなういくつかの予備計算を省略せずに示そ
う．
先ず鉄則０にしたがってrestartをかけ，関数を定義する．
> restart; f1:=unapply(x*exp(-beta*c*x^2)*(1+beta*g*x^3),x);
          /         2\ /            3\
x -> x exp\-beta c x / \1 + beta g x /
次には鉄則１にしたがって積分する前にどのような関数かプロットしてみる．そのままplotへ投げると怒られる．
> plot(f1(x),x=-10..10);
Warning, unable to evaluate the function to numeric values in the region; see
the plotting command's help page to ensure the calling sequence is correct
これは鉄則２にあるとおり，数値を代入すれば，beta,c,gなどのパラメータの値が入っていないためとわかる．
> f1(10);
                    10 exp(-100 beta c) (1 + 1000 beta g)
適当に値を代入する．
> c:=1; g:=0.01; beta:=0.1;
                                      1
                                     0.01
                                     0.1
再度プロットを試みる．
> plot(f1(x),x=-10..10);


実際に積分してみる．ここでは，鉄則３にしたがって，式を頭から打ち込むのではなく内側からみていくことが肝要である．これは問題を解いていく時に，思考が必ずたどるであ
ろう順番に相当する．
先ず変数に入れた数値をクリアする．
> c:='c': g:='g':beta:='beta':
不定積分でこの関数が積分できることを確認する．
> int(f1(x),x);
                                            /                    
                                            |                    
                                            |                    
                                            |   3    /         2\
                      1                     |  x  exp\-beta c x /
         - ----------------------- + beta g |- ------------------
                /        2\                 \       2 beta c     
           2 exp\beta c x / beta c                               

                /       /         2\     (1/2)    /        (1/2)  \\\
                |  x exp\-beta c x /   Pi      erf\(beta c)      x/||
              3 |- ----------------- + ----------------------------||
                |      2 beta c                            (1/2)   ||
                \                         4 beta c (beta c)        /|
            + ------------------------------------------------------|
                                     2 beta c                       /
次にx=-alpha..alphaの定積分を実行する．これは上記のコマンドに付け足すようにしていく．
> int(f1(x),x=-alpha..alpha);
             1            /  /       3    /             2\                (1/2)
- ----------------------- \g \4 alpha  exp\-beta c alpha / beta c (beta c)     
          2         (1/2)                                                      
  4 beta c  (beta c)                                                           

                /             2\         (1/2)
   + 6 alpha exp\-beta c alpha / (beta c)     

         (1/2)    /        (1/2)      \\\
   - 3 Pi      erf\(beta c)      alpha///
さらにα⇒∞としてみる．
> limit(int(f1(x),x=-alpha..alpha),alpha=infinity);
        /             1            /  /       3    /             2\        
   limit|- ----------------------- \g \4 alpha  exp\-beta c alpha / beta c 
        |          2         (1/2)                                         
        \  4 beta c  (beta c)                                              

             (1/2)              /             2\         (1/2)
     (beta c)      + 6 alpha exp\-beta c alpha / (beta c)     

            (1/2)    /        (1/2)      \\\                  \
      - 3 Pi      erf\(beta c)      alpha///, alpha = infinity|
                                                              |
                                                              /

ところがこれでは答えを返してくれない．積分した後のそれぞれの項を見るとβ*c>0を仮定すれば簡単になることが分る．assumeを使って，このような変数の仮定おこ
なう．
> assume(beta*c>0);
結果として最初に出した解答を得る．
> limit(int(f1(x),x=-alpha..alpha),alpha=infinity);
                                     (1/2)        
                                 3 Pi      g      
                           -----------------------
                                   2         (1/2)
                           4 beta c  (beta c)     
式のフォローのデフォルト

Mapleで実際に数式をいじる状況というのは，ほとんどの場合が既知の数式変形のフォローだろう．例えば，論文で「(1)式から(2)式への変形は自明である」とかいう
文章で済ましている変形が本当にあっているのかを確かめたい時．一番単純なやり方は自明と言われた前後の式が一致していることを確かめるだけで十分である．
最も単純な確認法は以下の通り，変形の前後の式を手入力してその差をexpandした結果が0か否かでする．
> ex1:=(x-3)^4;
                                          4
                                   (x - 3) 
> ex2:=x^4-12*x^3+54*x^2-108*x+81;
                        4       3       2             
                       x  - 12 x  + 54 x  - 108 x + 81
> expand(ex1-ex2);
                                      0

0ならば式の変形は保証されているので，その導出が間違いでなく誤植などもないことが確認できる．ただ，これだけでは変形の哲学や技法が身に付くわけではない．あくまでも
苦し紛れのデフォルトであることは心に留めておくように．
論理値として確かめたいときには，evalbを使う．
> evalb(expand(ex1-ex2)=0);
                                     true
> 
